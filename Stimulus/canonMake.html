
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>canonMake</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-11-07"><meta name="DC.source" content="canonMake.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>canonMake</h1><!--introduction--><pre>Creates "canonical" rhythm matricies, using the MIDI Toolbox note
representation. Rhtyhms can optionally be output to MIDI files using the
MIDI Toolbox 'writemidi' routine. The output can be any of all possible
permutations of the rhytym, in which one or more individual notes are iteratively
left out.</pre><pre>notes = canonMake(numer, denom, mType, mCode, varargin)</pre><pre>INPUT
numer - numerator of desired time signature. For complex time sigs (see
         below), this must equal the sum of the numerator divisions.
denom - denominator of desired time signature</pre><pre>mType &amp; mCode - metric type and code
  Lederahl &amp; Jackendoff metric structure specification.
         See below for algorithm details.
     mType = 'LJ' or 'lj'
     mCode = vector of 1 or more ratios between metric levels, starting
         from the lowest (shortest) levels.
         e.g., for compound 6/8, you'd pass "[3 2]".
         It's ok to pass irrationals for polyrhythms (e.g. 1.33), because the
         product of it and other ratios is rounded.
 Complex Meter
     mType = 'CX' or 'cx'
     mCode = vector of 1 or more numerator divisions. The sum must equal
         the numerator of the time signature. This represent a complex
         time signature. The first note gets a strong stress, then the begin
         of each division gets a weak stress, and the remainging notes are unstressed.
         This can also be used to create regular time signatures with
         irregular stress patterns.</pre><pre>Option parameters - param/value pairs:</pre><pre>'outfile' -   optional filename for output. Uses MIDI Toolbox 'writemidi'.
                 The file is written using 'numer', 'denom', 'bpm' and 'ticks' params.
'perm' -      [default 1] Single permutation # to create. They're made by iteratively
                         leaving out one or more notes. The numbering comes from the
                         algorithm used to create the permutations.
                         Pass 1 for full rhythm. If out-of-range, returns full rhythm.
'permCount' - [default 0] Flag. Pass 1 to simply return the # of
                         permutations possible for the passed
                         parameters. This takes the 'permIncludeFirst' &amp; 'permMin'
                         flags into account.
                         The permutation matrix is displayed.
'permAll' -   [default 0] Flag. Pass 1 to have all permutations created.
                     A cell matrix is returned containing all permutations.
                     If an outfile is specified, each is also written to an outfile,
                     and each permutation # is appended to outfile name.
'permMin' -   [default 2] - Minimum # of notes to have in a permutation.
                         This is to avoid permutations simply with a
                         note on first beat.
                         With value 2 and permIncludeFirst = 0, the
                         most sparse permutations will
                         have a note on 1st beat, and then one other position.
'permIncludeFirst' - [default 0] Flag. Pass 1 to have the permutations include
                         *leaving out* the first note, i.e. the downbeat.
'permV'   -   Permutation Vector. Pass a row vector of 1's and 0's to
                 specify a permutation mask to use instead of choosing
                 by 'perm' param. Must be of proper length, i.e. as long
                 as single repitition of the full rhythm.
'stress' -    [default 'auto'] stress pattern
   one of:
   'none' -  all notes unstressed
   'first' - stress first beat/note only
   'auto'    [default] - stress strong and weak notes, according to
                         metric structure.
Stress velocities:
  'strong' -  [default 127] MIDI velocity of strong stress, for first beat
  'weak' -    [default 96] MIDI velocity of weak stress, used in stress type 'auto'.
  'unstressed' - [default 64] MIDI velocity of unstressed beats.</pre><pre>'pitch' -     [default 48] MIDI pitch value for notes
'reps'   -    [default 1] Total # of repetitions of the rhythm. &gt;= 1.
'endSilence'  [default 0] Flag. Pass 1 to have N measures of silence after
                         the N repitions of the rhythm, with a single note
                         at begin of measure 2N+1 to signal the end.
'bpm' -       [default 120] - bpm, used to calculate event realtime second values,
                         and passed to optional file output.
                         *NOTE* This always specifies
                         quarter-notes/minute, regardless of time signature.
'ticks' -     [default 120] - ticks per beat for optional file output.
                             12/15/08 Not recommended to use something other than
                             120. Found a bug recently in MIDI Toolbox writemidi
                             that gave some buggy output if ticks-per-beat is not
                             120. Not sure it would effect these small files here,
                             but better to be safe.</pre><pre>OUTPUT
 Returns
  If 'permCount' option is set to 1:
     - displays the permutation matrix
     - returns the # of possible permutations for the passed settings.</pre><pre>Otherwise:
  notes - matrix of notes in 'nmat' format used by MIDI Toolbox.
         Each row represents one note, with these values by column:
             onset(beats), duration(beats), MIDI Channel, MIDI Pitch,
                 MIDI velocity, onset(seconds), duration(seconds)
         If 'permAll' is passed, output is a cell matrix with each permutation.</pre><pre>         NOTE that 'beats' actually means quarter notes. So that
         regardless of time signature, the beats are in terms of quarter
         notes. This is how MIDI Toolbox does it. Also, the onset and
         duration in terms of seconds are calculated using the bpm in
         terms of quarter-notes per minute, regardless of time
         signature.</pre><pre>DETAILS
  Lederal &amp; Jackendoff metric structures
     The vector of ratios is used to construct the rhythm in conjunction
     with the time signature. The time signature determines the duration
     in quarter notes of the full rhythm (a single measure). Each metric
     level contributes N equally-spaced notes within the rhythm, where N is # of
     notes on that level, deduced from the vector of ratios. These notes
     get a weak stress, except for the lowest (shortest) level, which is
     unstressed. This allows for defining polyrhythms, such as [1.5 2],
     which will yield 4 notes, with a strong stress on 1 and weak on the
     3rd note ('2-and' if 3/4 time signature).
     The first note always gets a strong stress.</pre><pre>     Although some polyrhythms will seem to be duplicated by permutations
     of straight rhythms, the stress patterns of polyrhythms are
     different, and thus can be useful.</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Params - check, get and set defaults.</a></li><li><a href="#4">check ticks value</a></li><li><a href="#5">Modify stress settings</a></li><li><a href="#6">Ticks per quarter note, used for internal calcs.</a></li><li><a href="#7">Complex meter</a></li><li><a href="#10">Lederal &amp; Jackendoff</a></li><li><a href="#12">Check if want back is the # of permutations.</a></li><li><a href="#13">Caclulate durations</a></li><li><a href="#14">Check Permutations</a></li><li><a href="#15">Finish up</a></li><li><a href="#17">Utility Functions</a></li><li><a href="#18">modifications</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> notes = canonMake(numer, denom, mType, mCode, varargin)
</pre><h2>Params - check, get and set defaults.<a name="3"></a></h2><pre class="codeinput">ps = inputParser;
ps.FunctionName = <span class="string">'canonMake'</span>;
ps.addRequired(<span class="string">'numer'</span>, @(x)x&gt;1 &amp;&amp; mod(x,1)==0);
ps.addRequired(<span class="string">'denom'</span>, @(x)numel(find([2 4 8 16 32] == x))&gt;0);
ps.addRequired(<span class="string">'mType'</span>, @ischar );
ps.addRequired(<span class="string">'mCode'</span>, @isnumeric);
ps.addParamValue(<span class="string">'outfile'</span>,<span class="string">''</span>, @ischar);
ps.addParamValue(<span class="string">'perm'</span>, 1, @(x)x&gt;0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'permCount'</span>, 0, @(x)x&gt;=0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'permAll'</span>,0,@(x)x&gt;=0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'permMin'</span>,2,@(x)x&gt;0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'permIncludeFirst'</span>,0,@(x)x&gt;=0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'permV'</span>,<span class="string">''</span>,@isnumeric);
ps.addParamValue(<span class="string">'stress'</span>, <span class="string">'auto'</span>, @ischar);
ps.addParamValue(<span class="string">'strong'</span>, 127, @(x) isnumeric(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;128);
ps.addParamValue(<span class="string">'weak'</span>, 96, @(x) isnumeric(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;128);
ps.addParamValue(<span class="string">'unstressed'</span>, 64, @(x) isnumeric(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;128);
ps.addParamValue(<span class="string">'pitch'</span>, 48, @(x) isnumeric(x) &amp;&amp; x&gt;=1 &amp;&amp; x&lt;128);
ps.addParamValue(<span class="string">'reps'</span>, 1, @(x)x&gt;0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'endSilence'</span>, 0, @(x)x&gt;=0&amp;&amp;isnumeric(x));
ps.addParamValue(<span class="string">'bpm'</span>, 120, @isnumeric);
ps.addParamValue(<span class="string">'ticks'</span>,120,@(x)x&gt;=120&amp;&amp;isnumeric(x));

ps.parse(numer, denom, mType, mCode, varargin{:});
p = ps.Results;
</pre><h2>check ticks value<a name="4"></a></h2><pre class="codeinput"><span class="keyword">if</span>( p.ticks ~= 120)
    warning(<span class="string">'\ncanonMake: ticks value is not 120. Read warnings in code comments. Proceeding.\n'</span>); <span class="comment">%#ok&lt;WNTAG&gt;</span>
<span class="keyword">end</span>
</pre><h2>Modify stress settings<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> strcmpi(p.stress,<span class="string">'none'</span>)
    <span class="comment">%all notes unstressed</span>
    p.strong = p.unstressed;
    p.weak = p.unstressed;
<span class="keyword">elseif</span> strcmpi(p.stress,<span class="string">'first'</span>)
    <span class="comment">%only first beat is stressed, so set weak stress value to unstressed</span>
    p.weak = p.unstressed;
<span class="keyword">elseif</span> strcmpi(p.stress,<span class="string">'auto'</span>) == 0
    error(<span class="string">'unrecognized stress param value'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
</pre><h2>Ticks per quarter note, used for internal calcs.<a name="6"></a></h2><pre>Realworld timing is done using bpm = quarter note / minute</pre><pre class="codeinput">tpq = 120; <span class="comment">%NOTE: see comments above</span>
<span class="comment">%ticks per measure (single loop of rhythm). denom is {2,4,8,16,32}</span>
tpm = p.numer * tpq * 4 / p.denom;

<span class="comment">%output note matrix</span>
notes = [];
</pre><h2>Complex meter<a name="7"></a></h2><pre class="codeinput"><span class="keyword">if</span> strcmpi(p.mType,<span class="string">'CX'</span>)
</pre><pre class="codeinput">    <span class="comment">%The numerator of the input time signature must match the</span>
    <span class="comment">% sum of the divisions in the complex time signature vector.</span>
    <span class="keyword">if</span> sum(p.mCode) ~= p.numer
        error(<span class="string">'canonMake: sum of complex time signature divisions must equal numerator.'</span>);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    dur = tpq * 4 / p.denom;
    inc = 0;
    <span class="keyword">for</span> d = 1:length(p.mCode)
       <span class="keyword">for</span> n = 1:p.mCode(d)
           vel = p.unstressed;
           <span class="keyword">if</span> n == 1 <span class="comment">%begin of each division is weakly stressed</span>
               vel = p.weak;
           <span class="keyword">end</span>
           notes = [notes; [dur*inc 0 1 p.pitch vel 0 0] ];
           inc = inc+1;
       <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2>Lederal &amp; Jackendoff<a name="10"></a></h2><pre class="codeinput"><span class="keyword">elseif</span> strcmpi(p.mType,<span class="string">'LJ'</span>)
    <span class="comment">%Go through each LJ level-ratio in the mCode vector and add notes at the</span>
    <span class="comment">% appropriate note duration for that level. This will handle polyrhythm</span>
    <span class="comment">% correctly.</span>
    numNotes = 1;
    <span class="comment">%Loop from highest (longest) level. The vector goes from lowest to</span>
    <span class="comment">%highest.</span>
    <span class="keyword">for</span> l = length(p.mCode):-1:1
       numNotes = round(numNotes .* mCode(l));
            <span class="comment">%call round() cuz for polyrhtyhms, can have ratios of 1.33</span>
       dur = tpm / numNotes;
       vel = p.weak;
       <span class="keyword">if</span> l == 1
           <span class="comment">%The lowest(shortest) level is not stressed (except first beat, handled below)</span>
           vel = p.unstressed;
       <span class="keyword">end</span>
       <span class="keyword">for</span> nn=1:numNotes
          notes = [notes; [dur*(nn-1) 0 1 p.pitch vel 0 0] ];
       <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">%Sort and remove duplicates.</span>
    [b,i,j]=unique(notes(:,1),<span class="string">'first'</span>);
    <span class="comment">%i holds array of first occurences of unique rows. Preserves</span>
    <span class="comment">% velocities of higher levels.</span>
    notes = notes(i,:);
<span class="keyword">else</span>
    error(<span class="string">'canonMake: unrecognized metric type'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
</pre><h2>Check if want back is the # of permutations.<a name="12"></a></h2><pre class="codeinput"><span class="keyword">if</span> p.permCount == 1
   prms = calcPerms(size(notes,1), p.permIncludeFirst, p.permMin);
   nums = 1:1:size(prms,1);
   disp(<span class="string">'     #     Permutation Mask'</span>);
   disp([nums' prms]);
   notes = size(prms,1);
   <span class="keyword">return</span>;
<span class="keyword">end</span>
</pre><h2>Caclulate durations<a name="13"></a></h2><pre class="codeinput"><span class="keyword">for</span> l=1:size(notes,1)
    <span class="keyword">if</span> l == size(notes,1)
       <span class="comment">%last note. make it last till end of measure</span>
       notes(l,2) = tpm - notes(l,1); <span class="comment">%#ok&lt;AGROW&gt;</span>
    <span class="keyword">else</span>
       <span class="comment">%otherwise, it lasts til next note. Handles polyrhythms.</span>
       notes(l,2) = notes(l+1,1) - notes(l,1); <span class="comment">%#ok&lt;AGROW&gt;</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%Full stress on first note</span>
notes(1,5) = p.strong; <span class="comment">%is set to unstressed value when 'none' passed for stress type</span>
</pre><h2>Check Permutations<a name="14"></a></h2><p>Check for a permutation vector to use directly</p><pre class="codeinput"><span class="keyword">if</span> ~isempty(p.permV)
    <span class="comment">%Check length</span>
    <span class="keyword">if</span>( length(p.permV) ~= size(notes,1) )
        error(<span class="string">'canonMake: permV vector must be length of rhythm: %d'</span>,size(notes,1));
    <span class="keyword">end</span>
    notes = notes(find(p.permV == 1), :); <span class="comment">%#ok&lt;FNDSB&gt;</span>

<span class="comment">% Determine which permutation to get, or all.</span>
<span class="keyword">elseif</span> p.permAll == 1 || p.perm &gt; 1
   <span class="comment">%Get array of all possible permutations, as rows of 1's &amp;&amp; 0's, representing which</span>
   <span class="comment">% notes should be included in each perm.</span>
   prms = calcPerms(size(notes,1), p.permIncludeFirst, p.permMin);
   <span class="keyword">if</span> p.permAll == 1
      <span class="comment">%return a cell array of each permutation.</span>
      notesCell = {};
      <span class="keyword">for</span> n=1:size(prms,1)
         notesCell{n} = notes(find(prms(n,:) == 1), :); <span class="comment">%#ok&lt;FNDSB,AGROW&gt;</span>
      <span class="keyword">end</span>
      notes = notesCell;
   <span class="keyword">else</span>
      <span class="comment">%Return a single permutation</span>
      <span class="comment">%If the perm # is out of range, just return full rhythm.</span>
      <span class="comment">%We already tested that it's &gt; 0 during init.</span>
      <span class="keyword">if</span> p.perm &lt;= size(prms,1)
        notes = notes(find(prms(p.perm,:) == 1), :); <span class="comment">%#ok&lt;FNDSB&gt;</span>
      <span class="keyword">else</span>
        warning(<span class="string">'perm parameter out-of-range. Returning full rhythm'</span>);  <span class="comment">%#ok&lt;WNTAG&gt;</span>
      <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Finish up<a name="15"></a></h2><pre class="codeinput">num = 1;
<span class="keyword">if</span> p.permAll == 1
    num = length(notesCell);
<span class="keyword">end</span>

<span class="keyword">for</span> nn = 1:num
    <span class="keyword">if</span> p.permAll == 1
        notes = notesCell{nn};
    <span class="keyword">end</span>

    <span class="comment">%Do repetitions</span>
    <span class="keyword">if</span> p.reps &gt; 1
       orig = notes;
       <span class="keyword">for</span> r = 1:p.reps-1
          next = orig;
          next(:,1) = next(:,1) + r*tpm;
          notes = [notes; next];  <span class="comment">%#ok&lt;AGROW&gt;</span>
       <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%Add end-note for silence</span>
    <span class="keyword">if</span> p.endSilence &gt; 0
        notes = [notes; [tpm*(2*p.reps) tpq 1 p.pitch p.unstressed 0 0]]; <span class="comment">%#ok&lt;AGROW&gt;</span>
    <span class="keyword">end</span>

    <span class="comment">%Convert from ticks to beat (quarter-note, actually) numbering</span>
    notes(:,[1 2]) = notes(:,[1 2]) / tpq;

    <span class="comment">%Calc the realtime onsets and durations.</span>
    notes(:,6) = notes(:,1) * 60 / p.bpm;
    notes(:,7) = notes(:,2) * 60 / p.bpm;

    <span class="keyword">if</span> p.permAll == 1
        notesCell{nn} = notes; <span class="comment">%#ok&lt;AGROW&gt;</span>
        notes = notesCell;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%Output file</span>
<span class="keyword">if</span> numel(p.outfile) &gt; 0
   <span class="keyword">if</span> p.permAll == 1
       <span class="comment">%Write out each permutation to a separate file.</span>
       [pathstr, name, ext, versn] = fileparts(p.outfile); <span class="comment">%#ok&lt;NASGU&gt;</span>
       <span class="keyword">for</span> n=1:length(notesCell)
            file = fullfile(pathstr,[name sprintf(<span class="string">'%05d'</span>,n) ext]);
            writemidi(notesCell{n}, file, p.ticks, p.bpm, p.numer, p.denom);
       <span class="keyword">end</span>
   <span class="keyword">else</span>
       writemidi(notes, p.outfile, p.ticks, p.bpm, p.numer, p.denom);
   <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2>Utility Functions<a name="17"></a></h2><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%Permutations.</span>
<span class="comment">%Creates an array of vectors, each row corresponding to a possible</span>
<span class="comment">% permutation of 1 and 0, with length N.</span>
<span class="comment">%Permutations are based on whether or not a given note from the full</span>
<span class="comment">% rhythm is included in the output, so it's a binary permutation.</span>
<span class="comment">%Do a find(res(n)) to find which notes should be included in</span>
<span class="comment">% permutation n.</span>
<span class="comment">%This is much more memory efficient than using builtin "perms" func,</span>
<span class="comment">% cuz that calcs all possible permutations by position which results</span>
<span class="comment">% in massive amount of permutations when you get up around N = 10, 11.</span>
<span class="comment">%</span>
<span class="keyword">function</span> res = calcPerms(N, includeFirstBeat, permMin)
    res = zeros(2^N, N);
    res = bifur(res);
    <span class="comment">%Check if should remove perms that start with 0</span>
    <span class="keyword">if</span>(includeFirstBeat == 0)
        res = res(1:end/2, :);
    <span class="keyword">end</span>
    <span class="comment">%Remove perms that don't have enough 1's (i.e., enough notes).</span>
    <span class="keyword">for</span> n=1:size(res,1)
       keep(n) = numel(find(res(n,:) &gt; 0)) &gt;= permMin;
    <span class="keyword">end</span>
    res = res(find(keep &gt; 0),:);
<span class="keyword">end</span>

<span class="keyword">function</span> res = bifur(res)
    <span class="comment">%"bifurcate" the passed array, setting '1' to first column of top half,</span>
    <span class="comment">% and '0' to first column of bottom half. Then call again sub-array, to</span>
    <span class="comment">% recursively create the whole permutations array.</span>
    res(1:end/2,1) = 1;
    res(end/2+1:end,1) = 0;
    <span class="keyword">if</span> size(res,2) &gt; 1
        res(1:end/2, 2:end) = bifur(res(1:end/2,2:end));
        res(end/2+1:end, 2:end) = bifur(res(end/2+1:end, 2:end));
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>modifications<a name="18"></a></h2><pre>** MODIFICATIONS **
01/07/08  MGS Created.
12/15/08  MGS Changed default 'ticks' value to 120. Added warning if
              not 120. See comments above under 'ticks' param.
01/12/09  MGS Changed 'endSilence' default to 0. Intending for main use
              to come from making sub-rhythms for subsequent concatenation.
              Changed 'reps' default to 1. Like above for 'endSilence'.
              Improved permutation display when set 'permCount';
              Adding 'permV' option to pass perumation mask vector
              directly.</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% canonMake
%
%  Creates "canonical" rhythm matricies, using the MIDI Toolbox note
%  representation. Rhtyhms can optionally be output to MIDI files using the
%  MIDI Toolbox 'writemidi' routine. The output can be any of all possible
%  permutations of the rhytym, in which one or more individual notes are iteratively
%  left out.
%
%  notes = canonMake(numer, denom, mType, mCode, varargin)
%
%  INPUT
%  numer - numerator of desired time signature. For complex time sigs (see
%           below), this must equal the sum of the numerator divisions.
%  denom - denominator of desired time signature
%
%  mType & mCode - metric type and code
%    Lederahl & Jackendoff metric structure specification.
%           See below for algorithm details.
%       mType = 'LJ' or 'lj'
%       mCode = vector of 1 or more ratios between metric levels, starting
%           from the lowest (shortest) levels.
%           e.g., for compound 6/8, you'd pass "[3 2]".
%           It's ok to pass irrationals for polyrhythms (e.g. 1.33), because the
%           product of it and other ratios is rounded.
%   Complex Meter
%       mType = 'CX' or 'cx'
%       mCode = vector of 1 or more numerator divisions. The sum must equal
%           the numerator of the time signature. This represent a complex
%           time signature. The first note gets a strong stress, then the begin 
%           of each division gets a weak stress, and the remainging notes are unstressed.
%           This can also be used to create regular time signatures with
%           irregular stress patterns.
%     
%  Option parameters - param/value pairs:
%
%  'outfile' -   optional filename for output. Uses MIDI Toolbox 'writemidi'.
%                   The file is written using 'numer', 'denom', 'bpm' and 'ticks' params.
%  'perm' -      [default 1] Single permutation # to create. They're made by iteratively
%                           leaving out one or more notes. The numbering comes from the
%                           algorithm used to create the permutations.
%                           Pass 1 for full rhythm. If out-of-range, returns full rhythm.
%  'permCount' - [default 0] Flag. Pass 1 to simply return the # of
%                           permutations possible for the passed
%                           parameters. This takes the 'permIncludeFirst' & 'permMin' 
%                           flags into account.
%                           The permutation matrix is displayed.
%  'permAll' -   [default 0] Flag. Pass 1 to have all permutations created. 
%                       A cell matrix is returned containing all permutations. 
%                       If an outfile is specified, each is also written to an outfile, 
%                       and each permutation # is appended to outfile name.
%  'permMin' -   [default 2] - Minimum # of notes to have in a permutation. 
%                           This is to avoid permutations simply with a
%                           note on first beat.
%                           With value 2 and permIncludeFirst = 0, the 
%                           most sparse permutations will 
%                           have a note on 1st beat, and then one other position.
%  'permIncludeFirst' - [default 0] Flag. Pass 1 to have the permutations include
%                           *leaving out* the first note, i.e. the downbeat.
%  'permV'   -   Permutation Vector. Pass a row vector of 1's and 0's to
%                   specify a permutation mask to use instead of choosing
%                   by 'perm' param. Must be of proper length, i.e. as long
%                   as single repitition of the full rhythm.
%  'stress' -    [default 'auto'] stress pattern
%     one of:
%     'none' -  all notes unstressed
%     'first' - stress first beat/note only
%     'auto'    [default] - stress strong and weak notes, according to
%                           metric structure.
%  Stress velocities:
%    'strong' -  [default 127] MIDI velocity of strong stress, for first beat
%    'weak' -    [default 96] MIDI velocity of weak stress, used in stress type 'auto'.
%    'unstressed' - [default 64] MIDI velocity of unstressed beats.
%
%  'pitch' -     [default 48] MIDI pitch value for notes
%  'reps'   -    [default 1] Total # of repetitions of the rhythm. >= 1.
%  'endSilence'  [default 0] Flag. Pass 1 to have N measures of silence after
%                           the N repitions of the rhythm, with a single note 
%                           at begin of measure 2N+1 to signal the end.
%  'bpm' -       [default 120] - bpm, used to calculate event realtime second values, 
%                           and passed to optional file output.
%                           *NOTE* This always specifies
%                           quarter-notes/minute, regardless of time signature.
%  'ticks' -     [default 120] - ticks per beat for optional file output.
%                               12/15/08 Not recommended to use something other than
%                               120. Found a bug recently in MIDI Toolbox writemidi
%                               that gave some buggy output if ticks-per-beat is not
%                               120. Not sure it would effect these small files here,
%                               but better to be safe.
%
%
%  OUTPUT
%   Returns
%    If 'permCount' option is set to 1:
%       - displays the permutation matrix
%       - returns the # of possible permutations for the passed settings.
%
%
%  Otherwise:
%    notes - matrix of notes in 'nmat' format used by MIDI Toolbox.
%           Each row represents one note, with these values by column:
%               onset(beats), duration(beats), MIDI Channel, MIDI Pitch,
%                   MIDI velocity, onset(seconds), duration(seconds)
%           If 'permAll' is passed, output is a cell matrix with each permutation.
%
%           NOTE that 'beats' actually means quarter notes. So that
%           regardless of time signature, the beats are in terms of quarter
%           notes. This is how MIDI Toolbox does it. Also, the onset and
%           duration in terms of seconds are calculated using the bpm in
%           terms of quarter-notes per minute, regardless of time
%           signature.
%
%  DETAILS
%    Lederal & Jackendoff metric structures
%       The vector of ratios is used to construct the rhythm in conjunction
%       with the time signature. The time signature determines the duration
%       in quarter notes of the full rhythm (a single measure). Each metric
%       level contributes N equally-spaced notes within the rhythm, where N is # of
%       notes on that level, deduced from the vector of ratios. These notes
%       get a weak stress, except for the lowest (shortest) level, which is
%       unstressed. This allows for defining polyrhythms, such as [1.5 2],
%       which will yield 4 notes, with a strong stress on 1 and weak on the 
%       3rd note ('2-and' if 3/4 time signature).
%       The first note always gets a strong stress.
%
%       Although some polyrhythms will seem to be duplicated by permutations
%       of straight rhythms, the stress patterns of polyrhythms are
%       different, and thus can be useful.

%%

function notes = canonMake(numer, denom, mType, mCode, varargin)


%% Params - check, get and set defaults.
ps = inputParser;
ps.FunctionName = 'canonMake';
ps.addRequired('numer', @(x)x>1 && mod(x,1)==0);
ps.addRequired('denom', @(x)numel(find([2 4 8 16 32] == x))>0);
ps.addRequired('mType', @ischar );
ps.addRequired('mCode', @isnumeric);
ps.addParamValue('outfile','', @ischar);
ps.addParamValue('perm', 1, @(x)x>0&&isnumeric(x));
ps.addParamValue('permCount', 0, @(x)x>=0&&isnumeric(x));
ps.addParamValue('permAll',0,@(x)x>=0&&isnumeric(x));
ps.addParamValue('permMin',2,@(x)x>0&&isnumeric(x));
ps.addParamValue('permIncludeFirst',0,@(x)x>=0&&isnumeric(x));
ps.addParamValue('permV','',@isnumeric);
ps.addParamValue('stress', 'auto', @ischar);
ps.addParamValue('strong', 127, @(x) isnumeric(x) && x>=0 && x<128);
ps.addParamValue('weak', 96, @(x) isnumeric(x) && x>=0 && x<128);
ps.addParamValue('unstressed', 64, @(x) isnumeric(x) && x>=0 && x<128);
ps.addParamValue('pitch', 48, @(x) isnumeric(x) && x>=1 && x<128);
ps.addParamValue('reps', 1, @(x)x>0&&isnumeric(x));
ps.addParamValue('endSilence', 0, @(x)x>=0&&isnumeric(x));
ps.addParamValue('bpm', 120, @isnumeric);
ps.addParamValue('ticks',120,@(x)x>=120&&isnumeric(x));

ps.parse(numer, denom, mType, mCode, varargin{:});
p = ps.Results;

%% check ticks value
if( p.ticks ~= 120)
    warning('\ncanonMake: ticks value is not 120. Read warnings in code comments. Proceeding.\n'); %#ok<WNTAG>
end

%% Modify stress settings
if strcmpi(p.stress,'none')
    %all notes unstressed
    p.strong = p.unstressed;
    p.weak = p.unstressed;
elseif strcmpi(p.stress,'first')
    %only first beat is stressed, so set weak stress value to unstressed
    p.weak = p.unstressed;
elseif strcmpi(p.stress,'auto') == 0
    error('unrecognized stress param value');
    return;
end

%% Ticks per quarter note, used for internal calcs.
%  Realworld timing is done using bpm = quarter note / minute
tpq = 120; %NOTE: see comments above
%ticks per measure (single loop of rhythm). denom is {2,4,8,16,32}
tpm = p.numer * tpq * 4 / p.denom;

%output note matrix
notes = [];


%% Complex meter
%
if strcmpi(p.mType,'CX')
    %The numerator of the input time signature must match the 
    % sum of the divisions in the complex time signature vector.
    if sum(p.mCode) ~= p.numer
        error('canonMake: sum of complex time signature divisions must equal numerator.');
        return;
    end
    dur = tpq * 4 / p.denom;
    inc = 0;
    for d = 1:length(p.mCode)
       for n = 1:p.mCode(d)
           vel = p.unstressed;
           if n == 1 %begin of each division is weakly stressed
               vel = p.weak;
           end
           notes = [notes; [dur*inc 0 1 p.pitch vel 0 0] ];
           inc = inc+1;
       end
    end
%%%

%% Lederal & Jackendoff
%
elseif strcmpi(p.mType,'LJ')
    %Go through each LJ level-ratio in the mCode vector and add notes at the
    % appropriate note duration for that level. This will handle polyrhythm
    % correctly.
    numNotes = 1;
    %Loop from highest (longest) level. The vector goes from lowest to
    %highest.
    for l = length(p.mCode):-1:1
       numNotes = round(numNotes .* mCode(l));
            %call round() cuz for polyrhtyhms, can have ratios of 1.33
       dur = tpm / numNotes;
       vel = p.weak;
       if l == 1
           %The lowest(shortest) level is not stressed (except first beat, handled below)
           vel = p.unstressed;
       end
       for nn=1:numNotes
          notes = [notes; [dur*(nn-1) 0 1 p.pitch vel 0 0] ];
       end
    end
    %Sort and remove duplicates.
    [b,i,j]=unique(notes(:,1),'first'); 
    %i holds array of first occurences of unique rows. Preserves
    % velocities of higher levels.
    notes = notes(i,:);
else
    error('canonMake: unrecognized metric type');
    return;
end    

%% Check if want back is the # of permutations.
if p.permCount == 1   
   prms = calcPerms(size(notes,1), p.permIncludeFirst, p.permMin);
   nums = 1:1:size(prms,1);
   disp('     #     Permutation Mask');
   disp([nums' prms]);
   notes = size(prms,1);
   return;
end

%% Caclulate durations
for l=1:size(notes,1)
    if l == size(notes,1)
       %last note. make it last till end of measure
       notes(l,2) = tpm - notes(l,1); %#ok<AGROW>
    else
       %otherwise, it lasts til next note. Handles polyrhythms.
       notes(l,2) = notes(l+1,1) - notes(l,1); %#ok<AGROW>
    end
end

%Full stress on first note
notes(1,5) = p.strong; %is set to unstressed value when 'none' passed for stress type

%% Check Permutations
% Check for a permutation vector to use directly
if ~isempty(p.permV)
    %Check length
    if( length(p.permV) ~= size(notes,1) )
        error('canonMake: permV vector must be length of rhythm: %d',size(notes,1));
    end
    notes = notes(find(p.permV == 1), :); %#ok<FNDSB>
    
% Determine which permutation to get, or all.
elseif p.permAll == 1 || p.perm > 1
   %Get array of all possible permutations, as rows of 1's && 0's, representing which
   % notes should be included in each perm.
   prms = calcPerms(size(notes,1), p.permIncludeFirst, p.permMin);
   if p.permAll == 1
      %return a cell array of each permutation.
      notesCell = {};
      for n=1:size(prms,1)
         notesCell{n} = notes(find(prms(n,:) == 1), :); %#ok<FNDSB,AGROW>
      end
      notes = notesCell;
   else
      %Return a single permutation
      %If the perm # is out of range, just return full rhythm.
      %We already tested that it's > 0 during init.
      if p.perm <= size(prms,1)
        notes = notes(find(prms(p.perm,:) == 1), :); %#ok<FNDSB>
      else
        warning('perm parameter out-of-range. Returning full rhythm');  %#ok<WNTAG>
      end
   end
end

%% Finish up
num = 1;
if p.permAll == 1
    num = length(notesCell);
end

for nn = 1:num
    if p.permAll == 1
        notes = notesCell{nn};
    end
    
    %Do repetitions
    if p.reps > 1
       orig = notes;
       for r = 1:p.reps-1
          next = orig;
          next(:,1) = next(:,1) + r*tpm;
          notes = [notes; next];  %#ok<AGROW>
       end
    end

    %Add end-note for silence
    if p.endSilence > 0
        notes = [notes; [tpm*(2*p.reps) tpq 1 p.pitch p.unstressed 0 0]]; %#ok<AGROW>
    end

    %Convert from ticks to beat (quarter-note, actually) numbering
    notes(:,[1 2]) = notes(:,[1 2]) / tpq;

    %Calc the realtime onsets and durations. 
    notes(:,6) = notes(:,1) * 60 / p.bpm;
    notes(:,7) = notes(:,2) * 60 / p.bpm;

    if p.permAll == 1
        notesCell{nn} = notes; %#ok<AGROW>
        notes = notesCell;
    end
end

%Output file
if numel(p.outfile) > 0
   if p.permAll == 1
       %Write out each permutation to a separate file.
       [pathstr, name, ext, versn] = fileparts(p.outfile); %#ok<NASGU>
       for n=1:length(notesCell)
            file = fullfile(pathstr,[name sprintf('%05d',n) ext]);
            writemidi(notesCell{n}, file, p.ticks, p.bpm, p.numer, p.denom);
       end
   else
       writemidi(notes, p.outfile, p.ticks, p.bpm, p.numer, p.denom);
   end
end
end


%% Utility Functions

%%%%%%%%%%%%%%%%%%%%%%%%%
%Permutations. 
%Creates an array of vectors, each row corresponding to a possible
% permutation of 1 and 0, with length N.
%Permutations are based on whether or not a given note from the full
% rhythm is included in the output, so it's a binary permutation.
%Do a find(res(n)) to find which notes should be included in 
% permutation n.
%This is much more memory efficient than using builtin "perms" func,
% cuz that calcs all possible permutations by position which results
% in massive amount of permutations when you get up around N = 10, 11.
%
function res = calcPerms(N, includeFirstBeat, permMin)
    res = zeros(2^N, N);
    res = bifur(res);
    %Check if should remove perms that start with 0
    if(includeFirstBeat == 0)
        res = res(1:end/2, :);
    end
    %Remove perms that don't have enough 1's (i.e., enough notes).
    for n=1:size(res,1)
       keep(n) = numel(find(res(n,:) > 0)) >= permMin;
    end
    res = res(find(keep > 0),:);
end

function res = bifur(res)
    %"bifurcate" the passed array, setting '1' to first column of top half,
    % and '0' to first column of bottom half. Then call again sub-array, to
    % recursively create the whole permutations array.
    res(1:end/2,1) = 1;
    res(end/2+1:end,1) = 0;
    if size(res,2) > 1
        res(1:end/2, 2:end) = bifur(res(1:end/2,2:end));
        res(end/2+1:end, 2:end) = bifur(res(end/2+1:end, 2:end));
    end
end

%% modifications
%  ** MODIFICATIONS **
%  01/07/08  MGS Created.
%  12/15/08  MGS Changed default 'ticks' value to 120. Added warning if
%                not 120. See comments above under 'ticks' param.
%  01/12/09  MGS Changed 'endSilence' default to 0. Intending for main use
%                to come from making sub-rhythms for subsequent concatenation.
%                Changed 'reps' default to 1. Like above for 'endSilence'.
%                Improved permutation display when set 'permCount';
%                Adding 'permV' option to pass perumation mask vector
%                directly.


##### SOURCE END #####
--></body></html>